--2018 Mohammad Rasmi Khashashneh
--
-- tank_game.script: controls the tank game behaviour
--
--Permission is hereby granted, free of charge, to any person obtaining a copy
--of this software and associated documentation files (the "Software"), to deal
--in the Software without restriction, including without limitation the rights
--to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
--copies of the Software, and to permit persons to whom the Software is
--furnished to do so, subject to the following conditions:
--
--The above copyright notice and this permission notice shall be included in all
--copies or substantial portions of the Software.
--
--THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
--AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
--UT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
--SOFTWARE.

-- Player and field default colors
local COLOR_P1 = vmath.vector4(0.44, 0.44, 1, 1)
local COLOR_P2 = vmath.vector4(0.78, 0.44, 0.76, 1)
local COLOR_FIELD = vmath.vector4(0.37, 0.47, 0.1, 1)
local COLOR_OBSTACLES = vmath.vector4(0.95, 0.76, 0.50, 1)
local P1 = "/p1"							-- P1 component path
local P2 = "/p2"							-- P2 component path
local LEVEL = "/tank_level"					-- level component path
local FIELD = "#field"						-- field component path
local BORDERS = "#borders"					-- borders component path
--local FIELD = "field"
--local SPRITE_P1_TANK = P1.."#tank"
--local SPRITE_P2_TANK = P2.."#tank"
--local SPRITE_FIELD = "#field"
-- TODO: can we define/include global variables? it would be best to define below constants once
local MSG_FIRE = "fire" 					-- A firing (bullet) message
local MSG_FORWARD = "forward"				-- A move (player) forward message
local MSG_ROTATE = "rotate"					-- A rotate (player) message
local MSG_ROTATE_COUNTER = "rotate_counter"	-- A counter clockwise rotate (player) message
local MSG_START = "start"					-- A start game message
local MSG_IS_HIT = "is_hit"					-- A player (being) hit message
--local MSG_SET_LEVEL = "set_level"
local P1_CNTRL_PREFIX = "p1_"
local P2_CNTRL_PREFIX = "p2_"
local BULLET_FACTORY = "#bullet_factory"
local BULLET_SPAWN_OFFSET = vmath.vector3(8, 0, 0)
local MSG_BULLET_PLAYER_HIT = "bullet_player_hit"
local demo = true
local DEMO_TIMEOUT = 3
local active_tanks = {}
local FR = 60/10

function init(self)
	msg.post(".", "acquire_input_focus")
	-- Initializing field and tank colors
	-- TODO: use go properties instead
	go.set("/p1#tank1", "level", go.get_id())
	go.set("/p2#tank1", "level", go.get_id())
	go.set("/p1#tank1", "color", COLOR_P1)
	go.set("/p2#tank1", "color", COLOR_P2)
	self.p1_score = 0
	self.p2_score = 0
	self.demo_timer = DEMO_TIMEOUT
	self.tank_move_sound = false
	self.rate = 0
	self.delta = 0
end

function get_random_color(base)
	local col = vmath.vector4(base)
	col.x = math.random()
--	col.y = math.random()
	col.z = math.random()
	return col
end

function init_colors()
	sprite.set_constant(FIELD, "tint", COLOR_FIELD)
	sprite.set_constant("/p1#tank", "tint", COLOR_P1)
	sprite.set_constant("#p1_tens", "tint", COLOR_P1)
	sprite.set_constant("#p1_ones", "tint", COLOR_P1)
	sprite.set_constant("/p2#tank", "tint", COLOR_P2)
	sprite.set_constant("#p2_tens", "tint", COLOR_P2)
	sprite.set_constant("#p2_ones", "tint", COLOR_P2)
	sprite.set_constant(BORDERS, "tint", COLOR_OBSTACLES)
end

function update(self, dt)
	if demo then
		local col
		self.demo_timer = self.demo_timer + dt
		if(self.demo_timer > DEMO_TIMEOUT) then
			self.demo_timer = 0
			sprite.set_constant(FIELD, "tint", get_random_color(COLOR_FIELD))
			col = get_random_color(COLOR_P1)
			sprite.set_constant("/p1#tank", "tint", col)
			sprite.set_constant("#p1_tens", "tint", col)
			sprite.set_constant("#p1_ones", "tint", col)
			col = get_random_color(COLOR_P2)
			sprite.set_constant("/p2#tank", "tint", col)
			sprite.set_constant("#p2_tens", "tint", col)
			sprite.set_constant("#p2_ones", "tint", col)
			sprite.set_constant(BORDERS, "tint", get_random_color(COLOR_OBSTACLES))
		end	
	else
		self.delta = dt
	--[[else
		if active_tanks[P1_CNTRL_PREFIX] then
			check_input(self, active_tanks[P1_CNTRL_PREFIX], P1, P1_CNTRL_PREFIX)
		end
		if active_tanks[P2_CNTRL_PREFIX] then
			check_input(self, active_tanks[P2_CNTRL_PREFIX], P2, P2_CNTRL_PREFIX)
		end]]--
	end
end

function fire_bullet(player)
	local rot = go.get_rotation(player)
	local pos = go.get_position(player) + vmath.rotate(rot, BULLET_SPAWN_OFFSET)
	pos.z = 0.3
	local id = factory.create(BULLET_FACTORY, pos, rot, {pong = false, level = go.get_id()})
	sprite.set_constant(id, "tint", go.get(player.."#tank1", "color")) --colors[player..TANK_SPRITE]
end

function reset_positions()
end

function reset_level()
	reset_positions()
	init_colors()
	print("play01")
	msg.post("#level_noise_02", "play_sound")
end

function activate_tank(self, action_id, player, prefix)
	local action
	if action_id == hash(prefix .. MSG_FIRE) then
		action = MSG_FIRE
		--fire_bullet(player)
	elseif action_id == hash(prefix .. MSG_FORWARD) then
		--msg.post(player, MSG_FORWARD)
		action = MSG_FORWARD
		--if not self.tank_move_sound then
		msg.post("#level_noise_02", "stop_sound")
		msg.post("#tank_move", "play_sound")
			--self.tank_move_sound = true
		--end
	elseif action_id == hash(prefix .. MSG_ROTATE) then
		--msg.post(player, MSG_ROTATE)
		action = MSG_ROTATE
	elseif action_id == hash(prefix .. MSG_ROTATE_COUNTER) then
		--msg.post(player, MSG_ROTATE_COUNTER)
		action = MSG_ROTATE_COUNTER
	end
	--active_tanks[prefix] = hash(action)
end

function deactivate_tank(self, action_id, player, prefix)
	if action_id == hash(prefix .. MSG_FORWARD) then
		msg.post("#tank_move", "stop_sound")
		print("play03 ", action_id)
		msg.post("#level_noise_02", "play_sound")
	end	
	--[[if active_tanks[prefix] then
		print("play04")
		active_tanks[prefix] = nil
	end]]--
end

function check_input(self, action_id, action, player, prefix)
	-- FIXME CONTINUE 2018/08/15: Disabling below block, results in fault of handling rotations 
	--[[print("FR ", self.rate,"/",FR,", delta is ", self.delta)
	if self.rate < 2 then
		self.rate = self.rate + self.delta
		return
	else
		self.rate = 0
	end]]--
	print("ci 00", action_id, player, prefix)
	if action_id == hash(prefix .. MSG_FIRE) and action.pressed then
		fire_bullet(player)
	elseif action_id == hash(prefix .. MSG_FORWARD) and action.repeated then
		msg.post(player, MSG_FORWARD)
		--[[if not self.tank_move_sound then
			msg.post("#tank_move", "play_sound")
			self.tank_move_sound = true
		end]]--
	elseif action_id == hash(prefix .. MSG_ROTATE) then
		msg.post(player, MSG_ROTATE)
	elseif action_id == hash(prefix .. MSG_ROTATE_COUNTER) then
		msg.post(player, MSG_ROTATE_COUNTER)
	end
end

function on_input(self, action_id, action)
	-- FIXME: tank movement pauses briefely
	--if(not action.repeated) then
		--return
	--end
	if action_id == hash(MSG_START) and action.pressed then
		demo = false
		reset_level()
	end
	if not demo then
		if action.pressed then
			activate_tank(self, action_id, P1, P1_CNTRL_PREFIX)
			activate_tank(self, action_id, P2, P2_CNTRL_PREFIX)
		elseif action.released then
			deactivate_tank(self, action_id, P1, P1_CNTRL_PREFIX)
			deactivate_tank(self, action_id, P2, P2_CNTRL_PREFIX)
		end	
		check_input(self, action_id, action, P1, P1_CNTRL_PREFIX)
		check_input(self, action_id, action, P2, P2_CNTRL_PREFIX)
	end
end

function update_scores(score_prefix, score)
	local tens = math.floor(score * 0.1)
	local ones = score - (tens * 10)
	--print(tens, ones)
	msg.post(score_prefix.."tens", "play_animation", {id = hash("num_0"..tens)})
	msg.post(score_prefix.."ones", "play_animation", {id = hash("num_0"..ones)})
end

function on_message(self, message_id, message)
	if message_id == hash(MSG_IS_HIT) then
		if message.player == hash(P1) then
			self.p2_score = self.p2_score + 1
			update_scores("#p2_", self.p2_score)
		elseif message.player == hash(P2) then
			self.p1_score = self.p1_score + 1
			update_scores("#p1_", self.p1_score)
		end
	end
end