--2018 Mohammad Rasmi Khashashneh
--
-- tank_game.script: controls the tank game behaviour
--
--Permission is hereby granted, free of charge, to any person obtaining a copy
--of this software and associated documentation files (the "Software"), to deal
--in the Software without restriction, including without limitation the rights
--to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
--copies of the Software, and to permit persons to whom the Software is
--furnished to do so, subject to the following conditions:
--
--The above copyright notice and this permission notice shall be included in all
--copies or substantial portions of the Software.
--
--THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
--IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
--FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
--AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
--LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
--UT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
--SOFTWARE.

-- Player and field default colors
local COLOR_P1 = vmath.vector4(0.44, 0.44, 1, 1)
local COLOR_P2 = vmath.vector4(0.78, 0.44, 0.76, 1)
local COLOR_FIELD = vmath.vector4(0.37, 0.47, 0.1, 1)
local COLOR_OBSTACLES = vmath.vector4(0.95, 0.76, 0.50, 1)
local P1 = "/p1"					-- P1 component path
local P2 = "/p2"					-- P2 component path
local LEVEL = "/tank_level"			-- level component path
local FIELD = "#field"				-- field component path
local BORDERS = "#borders"			-- borders component path
--local FIELD = "field"
--local SPRITE_P1_TANK = P1.."#tank"
--local SPRITE_P2_TANK = P2.."#tank"
--local SPRITE_FIELD = "#field"
-- TODO: can we define/include global variables?
local MSG_FIRE = "fire"
local MSG_FORWARD = "forward"
local MSG_ROTATE = "rotate"
local MSG_ROTATE_COUNTER = "rotate_counter"
local MSG_START = "start"
local MSG_IS_HIT = "is_hit"
--local MSG_SET_LEVEL = "set_level"
local P1_CNTRL_PREFIX = "p1_"
local P2_CNTRL_PREFIX = "p2_"
local BULLET_FACTORY = "#bullet_factory"
local BULLET_SPAWN_OFFSET = vmath.vector3(8, 0, 0)
local MSG_BULLET_PLAYER_HIT = "bullet_player_hit"
local demo = true
local DEMO_TIMEOUT = 3

function init(self)
	msg.post(".", "acquire_input_focus")
	-- Initializing field and tank colors
	-- TODO: use go properties instead
	go.set("/p1#tank1", "level", go.get_id())
	go.set("/p2#tank1", "level", go.get_id())
	go.set("/p1#tank1", "color", COLOR_P1)
	go.set("/p2#tank1", "color", COLOR_P2)
	self.p1_score = 0
	self.p2_score = 0
	self.demo_timer = DEMO_TIMEOUT
end

function get_random_color(base)
	local col = vmath.vector4(base)
	col.x = math.random()
--	col.y = math.random()
	col.z = math.random()
	return col
end

function init_colors()
	sprite.set_constant(FIELD, "tint", COLOR_FIELD)
	sprite.set_constant("/p1#tank", "tint", COLOR_P1)
	sprite.set_constant("#p1_tens", "tint", COLOR_P1)
	sprite.set_constant("#p1_ones", "tint", COLOR_P1)
	sprite.set_constant("/p2#tank", "tint", COLOR_P2)
	sprite.set_constant("#p2_tens", "tint", COLOR_P2)
	sprite.set_constant("#p2_ones", "tint", COLOR_P2)
	sprite.set_constant(BORDERS, "tint", COLOR_OBSTACLES)
end

function update(self, dt)
	if demo then
		local col
		self.demo_timer = self.demo_timer + dt
		if(self.demo_timer > DEMO_TIMEOUT) then
			self.demo_timer = 0
			sprite.set_constant(FIELD, "tint", get_random_color(COLOR_FIELD))
			col = get_random_color(COLOR_P1)
			sprite.set_constant("/p1#tank", "tint", col)
			sprite.set_constant("#p1_tens", "tint", col)
			sprite.set_constant("#p1_ones", "tint", col)
			col = get_random_color(COLOR_P2)
			sprite.set_constant("/p2#tank", "tint", col)
			sprite.set_constant("#p2_tens", "tint", col)
			sprite.set_constant("#p2_ones", "tint", col)
			sprite.set_constant(BORDERS, "tint", get_random_color(COLOR_OBSTACLES))
		end	
	end
end

function fire_bullet(player)
	local rot = go.get_rotation(player)
	local pos = go.get_position(player) + vmath.rotate(rot, BULLET_SPAWN_OFFSET)
	pos.z = 0.3
	local id = factory.create(BULLET_FACTORY, pos, rot, {pong = false, level = go.get_id()})
	sprite.set_constant(id, "tint", go.get(player.."#tank1", "color")) --colors[player..TANK_SPRITE]
end

function reset_positions()
end

function reset_level()
	reset_positions()
	init_colors()
end

function check_input(action_id, player, prefix)
	if action_id == hash(prefix .. MSG_FIRE) then
		fire_bullet(player)
	elseif action_id == hash(prefix .. MSG_FORWARD) then
		msg.post(player, MSG_FORWARD)
	elseif action_id == hash(prefix .. MSG_ROTATE) then
		msg.post(player, MSG_ROTATE)
	elseif action_id == hash(prefix .. MSG_ROTATE_COUNTER) then
		msg.post(player, MSG_ROTATE_COUNTER)
	end
end

function on_input(self, action_id, action)
	-- FIXME: tank movement pauses briefely
	if(not action.repeated) then
		return
	end
	if action_id == hash(MSG_START) then
		demo = false
		reset_level()
	end
	if not demo then
		check_input(action_id, P1, P1_CNTRL_PREFIX)
		check_input(action_id, P2, P2_CNTRL_PREFIX)
	end
end

function update_scores(score_prefix, score)
	local tens = math.floor(score * 0.1)
	local ones = score - (tens * 10)
	print(tens, ones)
	msg.post(score_prefix.."tens", "play_animation", {id = hash("num_0"..tens)})
	msg.post(score_prefix.."ones", "play_animation", {id = hash("num_0"..ones)})
end

function on_message(self, message_id, message)
	if message_id == hash(MSG_IS_HIT) then
		if message.player == hash(P1) then
			self.p2_score = self.p2_score + 1
			update_scores("#p2_", self.p2_score)
		elseif message.player == hash(P2) then
			self.p1_score = self.p1_score + 1
			update_scores("#p1_", self.p1_score)
		end
	end
end